package service

import (
	"bookings-api/internal/clients"
	"bookings-api/internal/dao"
	"bookings-api/internal/domain"
	"bookings-api/internal/publisher"
	"bookings-api/internal/repository"
	"context"
	"errors"
	"fmt"

	"github.com/rs/zerolog/log"
	"gorm.io/gorm"
)

// BookingService defines the interface for booking business operations
type BookingService interface {
	// CreateBooking creates a new booking with validation
	CreateBooking(ctx context.Context, req domain.CreateBookingRequest) (*domain.BookingResponse, error)

	// GetBooking retrieves a booking by ID
	GetBooking(ctx context.Context, bookingID string) (*domain.BookingResponse, error)

	// GetPassengerBookings retrieves all bookings for a passenger with pagination
	GetPassengerBookings(ctx context.Context, passengerID int64, page, limit int) (*domain.BookingListResponse, error)

	// CancelBooking cancels a booking (must be passenger or driver)
	CancelBooking(ctx context.Context, bookingID string, userID int64, reason string) error
}

// bookingService implements BookingService
type bookingService struct {
	bookingRepo repository.BookingRepository
	tripsClient clients.TripsClient
	publisher   publisher.Publisher
}

// NewBookingService creates a new BookingService with dependency injection
func NewBookingService(
	bookingRepo repository.BookingRepository,
	tripsClient clients.TripsClient,
	pub publisher.Publisher,
) BookingService {
	return &bookingService{
		bookingRepo: bookingRepo,
		tripsClient: tripsClient,
		publisher:   pub,
	}
}

// CreateBooking creates a new booking with async validation via events
// Validation is performed asynchronously by trips-api via reservation.created event
func (s *bookingService) CreateBooking(ctx context.Context, req domain.CreateBookingRequest) (*domain.BookingResponse, error) {
	log.Info().
		Str("trip_id", req.TripID).
		Int64("passenger_id", req.PassengerID).
		Int("seats_reserved", req.SeatsReserved).
		Msg("Creating booking (async validation)")

	// Step 1: Check for existing bookings (no duplicate bookings for same passenger+trip)
	// This is the only synchronous validation we perform locally
	existingBookings, err := s.bookingRepo.FindByTripID(req.TripID)
	if err != nil {
		log.Error().
			Err(err).
			Str("trip_id", req.TripID).
			Msg("Failed to check for existing bookings")
		return nil, fmt.Errorf("failed to check existing bookings: %w", err)
	}

	for _, existingBooking := range existingBookings {
		if existingBooking.PassengerID == req.PassengerID &&
			!existingBooking.IsCancelled() &&
			!existingBooking.IsFailed() {
			log.Warn().
				Str("trip_id", req.TripID).
				Int64("passenger_id", req.PassengerID).
				Str("existing_booking_id", existingBooking.BookingUUID).
				Msg("Duplicate booking detected")
			return nil, domain.ErrDuplicateBooking.WithDetails(map[string]interface{}{
				"trip_id":             req.TripID,
				"passenger_id":        req.PassengerID,
				"existing_booking_id": existingBooking.BookingUUID,
			})
		}
	}

	// Step 2: Create booking entity in pending state
	// All other validations (trip status, seats availability, etc.) will be done asynchronously by trips-api
	// Total price will be set to 0 initially and updated when trips-api confirms the reservation
	booking := &dao.Booking{
		// BookingUUID will be auto-generated by GORM BeforeCreate hook
		TripID:         req.TripID,
		PassengerID:    req.PassengerID,
		SeatsRequested: req.SeatsReserved,
		TotalPrice:     0, // Will be updated when trips-api confirms with reservation.confirmed event
		Status:         dao.BookingStatusPending,
		// CreatedAt and UpdatedAt will be auto-managed by GORM
	}

	// Step 3: Save to database
	if err := s.bookingRepo.Create(booking); err != nil {
		log.Error().
			Err(err).
			Str("trip_id", req.TripID).
			Int64("passenger_id", req.PassengerID).
			Msg("Failed to create booking in database")
		return nil, fmt.Errorf("failed to create booking: %w", err)
	}

	log.Info().
		Str("booking_id", booking.BookingUUID).
		Str("trip_id", booking.TripID).
		Int64("passenger_id", booking.PassengerID).
		Int("seats", booking.SeatsRequested).
		Float64("total_price", booking.TotalPrice).
		Msg("✅ Booking created successfully in pending state")

	// Step 4: Publish reservation.created event to RabbitMQ for async validation
	// trips-api will validate and respond with reservation.confirmed or reservation.failed
	// IMPORTANT: Eventual consistency pattern - if publish fails, DON'T rollback database
	// The booking is already saved (source of truth), event is just a notification
	if err := s.publisher.PublishReservationCreated(
		booking.TripID,
		booking.PassengerID,
		booking.SeatsRequested,
		booking.BookingUUID,
	); err != nil {
		// Log error but DON'T return error to user
		// Database is source of truth, event publish failure doesn't invalidate booking
		log.Error().
			Err(err).
			Str("booking_id", booking.BookingUUID).
			Str("trip_id", booking.TripID).
			Int("seats_reserved", booking.SeatsRequested).
			Msg("⚠️  Booking created but failed to publish reservation.created event (eventual consistency)")
		// Continue and return success - trips-api can sync via reconciliation if needed
	} else {
		log.Info().
			Str("booking_id", booking.BookingUUID).
			Str("event_type", "reservation.created").
			Msg("✅ Reservation event published successfully - awaiting async validation from trips-api")
	}

	// Step 5: Return response DTO
	// Booking is in pending state - will be updated to confirmed/failed by trips-api event
	return domain.ToBookingResponse(booking), nil
}

// GetBooking retrieves a booking by ID
func (s *bookingService) GetBooking(ctx context.Context, bookingID string) (*domain.BookingResponse, error) {
	log.Debug().Str("booking_id", bookingID).Msg("Getting booking")

	booking, err := s.bookingRepo.FindByID(bookingID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			log.Warn().Str("booking_id", bookingID).Msg("Booking not found")
			return nil, domain.ErrBookingNotFound.WithDetails(map[string]interface{}{
				"booking_id": bookingID,
			})
		}
		log.Error().Err(err).Str("booking_id", bookingID).Msg("Failed to get booking")
		return nil, fmt.Errorf("failed to get booking: %w", err)
	}

	return domain.ToBookingResponse(booking), nil
}

// GetPassengerBookings retrieves all bookings for a passenger with pagination
func (s *bookingService) GetPassengerBookings(ctx context.Context, passengerID int64, page, limit int) (*domain.BookingListResponse, error) {
	log.Debug().
		Int64("passenger_id", passengerID).
		Int("page", page).
		Int("limit", limit).
		Msg("Getting passenger bookings")

	// Validate pagination parameters
	if page < 1 {
		page = 1
	}
	if limit < 1 || limit > 100 {
		limit = 10 // Default limit
	}

	bookings, total, err := s.bookingRepo.FindByPassengerID(passengerID, page, limit)
	if err != nil {
		log.Error().
			Err(err).
			Int64("passenger_id", passengerID).
			Msg("Failed to get passenger bookings")
		return nil, fmt.Errorf("failed to get passenger bookings: %w", err)
	}

	log.Info().
		Int64("passenger_id", passengerID).
		Int64("total", total).
		Int("returned", len(bookings)).
		Msg("Retrieved passenger bookings")

	return domain.NewBookingListResponse(bookings, total, page, limit), nil
}

// CancelBooking cancels a booking (authorization check: must be passenger or driver)
func (s *bookingService) CancelBooking(ctx context.Context, bookingID string, userID int64, reason string) error {
	log.Info().
		Str("booking_id", bookingID).
		Int64("user_id", userID).
		Str("reason", reason).
		Msg("Cancelling booking")

	// Step 1: Get the booking
	booking, err := s.bookingRepo.FindByID(bookingID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			log.Warn().Str("booking_id", bookingID).Msg("Booking not found")
			return domain.ErrBookingNotFound.WithDetails(map[string]interface{}{
				"booking_id": bookingID,
			})
		}
		log.Error().Err(err).Str("booking_id", bookingID).Msg("Failed to get booking")
		return fmt.Errorf("failed to get booking: %w", err)
	}

	// Step 2: Authorization check - must be passenger or driver
	// Using local data from booking (driver_id populated on confirmation)
	isPassenger := booking.PassengerID == userID
	isDriver := booking.DriverID == userID

	if !isPassenger && !isDriver {
		log.Warn().
			Str("booking_id", bookingID).
			Int64("user_id", userID).
			Int64("passenger_id", booking.PassengerID).
			Int64("driver_id", booking.DriverID).
			Msg("Unauthorized cancellation attempt")
		return domain.ErrUnauthorized.WithDetails(map[string]interface{}{
			"booking_id": bookingID,
			"user_id":    userID,
		})
	}

	// Step 3: Validate booking can be cancelled (cannot cancel completed bookings)
	if booking.IsCompleted() {
		log.Warn().
			Str("booking_id", bookingID).
			Str("status", booking.Status).
			Msg("Cannot cancel completed booking")
		return domain.ErrCannotCancelCompleted.WithDetails(map[string]interface{}{
			"booking_id": bookingID,
			"status":     booking.Status,
		})
	}

	// Step 4: Check if already cancelled
	if booking.IsCancelled() {
		log.Warn().
			Str("booking_id", bookingID).
			Str("status", booking.Status).
			Msg("Cannot cancel - booking already cancelled")
		return domain.ErrBookingAlreadyCancelled.WithDetails(map[string]interface{}{
			"booking_id": bookingID,
			"status":     booking.Status,
		})
	}

	// Step 5: Cancel the booking
	if err := s.bookingRepo.CancelBooking(bookingID, reason); err != nil {
		log.Error().
			Err(err).
			Str("booking_id", bookingID).
			Msg("Failed to cancel booking")
		return fmt.Errorf("failed to cancel booking: %w", err)
	}

	log.Info().
		Str("booking_id", bookingID).
		Int64("user_id", userID).
		Bool("is_passenger", isPassenger).
		Bool("is_driver", isDriver).
		Msg("✅ Booking cancelled successfully")

	// Step 6: Publish reservation.cancelled event to RabbitMQ
	// IMPORTANT: Eventual consistency pattern - if publish fails, DON'T rollback database
	// The booking is already cancelled (source of truth), event is just a notification
	if err := s.publisher.PublishReservationCancelled(
		booking.TripID,
		booking.SeatsRequested,
		booking.BookingUUID,
	); err != nil {
		// Log error but DON'T return error to user
		// Database is source of truth, event publish failure doesn't invalidate cancellation
		log.Error().
			Err(err).
			Str("booking_id", booking.BookingUUID).
			Str("trip_id", booking.TripID).
			Int("seats_released", booking.SeatsRequested).
			Msg("⚠️  Booking cancelled but failed to publish reservation.cancelled event (eventual consistency)")
		// Continue and return success - trips-api can sync via reconciliation if needed
	} else {
		log.Info().
			Str("booking_id", booking.BookingUUID).
			Str("event_type", "reservation.cancelled").
			Msg("✅ Reservation cancelled event published successfully")
	}

	return nil
}
